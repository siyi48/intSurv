% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\name{surv.hte}
\alias{surv.hte}
\title{Integrative estimation of the heterogeneous treatment effect with the use of
sieve approximation}
\usage{
surv.hte(
  tau.mat,
  c1.mat,
  c1.discrete = NULL,
  q.c1,
  c0.mat,
  c0.discrete = NULL,
  q.c0,
  lambda.mat,
  lambda.discrete = NULL,
  q.lambda,
  basis.type = "poly.raw",
  a,
  s,
  t,
  delta,
  nfolds = 5,
  type = "int"
)
}
\arguments{
\item{tau.mat}{the matrix that contains the covariate terms of \eqn{\tau(X)}.}

\item{c1.mat}{the matrix that contains the continuous covariates which may
affect \eqn{c_1(X)}.}

\item{c1.discrete}{the matrix that contains the discrete covariates which may
affect \eqn{c_1(X)}. The default is \code{NULL}.}

\item{q.c1}{the number of basis functions to approximate each continuous
covariate in \eqn{c_1(X)}. Here, it corresponds to the degree of freedom to
generate the polynomial basis.}

\item{c0.mat}{the matrix that contains the continuous covariates which may
affect \eqn{c_0(X)}.}

\item{c0.discrete}{the matrix that contains the discrete covariates which may
affect \eqn{c_0(X)}. The default is \code{NULL}.}

\item{q.c0}{the number of basis functions to approximate each continuous
covariate in \eqn{c_0(X)}. Here, it corresponds to the degree of freedom to
generate the polynomial basis.}

\item{lambda.mat}{the matrix that contains the continuous covariates which
may affect \eqn{\lambda(X)}.}

\item{lambda.discrete}{the matrix that contains the discrete covariates
which may affect \eqn{\lambda(X)}.}

\item{q.lambda}{the number of basis functions to approximate each continuous
covariate in \eqn{\lambda(X)}. Here, it corresponds to the degree of freedom
to generate the polynomial basis.}

\item{basis.type}{the type of basis used to approximate the nuisance functions,
including
\itemize{
\item \code{poly.raw}: the raw polynomial basis. The default type of the basis.
\item \code{poly.orthogonal}: the orthogonal polynomial basis
\item \code{bs}: the B-spline basis for a polynomial spline
}}

\item{a}{the binary treatment assignment, where the active treatment group
should be encoded as \code{1}, and the control group should be encoded as \code{0}.}

\item{s}{the binary data source indicator, where the trial data should be
encoded as \code{1}, and the observational study should be encoded as \code{0}.}

\item{t}{the observed event time.}

\item{delta}{the event indicator.}

\item{nfolds}{the fold of cross-validation, the default value is \code{5}.}

\item{type}{the type of estimator the user want to obtain. Available types
include
\itemize{
\item \code{int}: the integrative estimator that combines the trial data and the
observational study data;
\item \code{rct}: the trial estimator.
}}
}
\value{
a list of estimators, including
\itemize{
\item \code{beta.est}: the estimated treatment effect parameter
\item \code{ve.beta}: the variance estimate of the estimated treatment effect
\item \code{cov.beta}: the covariance matrix of the estimated treatment effect
parameter
\item \code{ate.est}: the estimated average treatment effect
\item \code{ve.ate}: the variance estimate of the average treatment effect
\item \code{psi.est}: the estimated confounding function parameter
}
}
\description{
This function is the main function of obtaining the integrative estimator
with its variance estimates. The integrative estimator is obtained by
minimizing the penalized log partial likelihood, with the penalty function
selected as the adaptive lasso.
}
\examples{
q.c1 <- 3
q.c0 <- 3
q.lambda <- 3
nfolds <- 5
c1.mat <- matrix(dat$x1, ncol = 1)
c1.discrete <- matrix(dat$x2, ncol = 1)
c0.mat <- matrix(dat$x1, ncol = 1)
c0.discrete <- matrix(dat$x2, ncol = 1)
lambda.mat <-  matrix(dat$x1, ncol = 1)
lambda.discrete <- cbind(1, dat$x2)
tau.mat <- cbind(1, dat$x1, dat$x1^2)
s <- dat$s
delta <- dat$delta
t <- dat$t
a <- dat$a
res.hte <- surv.hte(tau.mat = tau.mat, c1.mat = c1.mat,
c1.discrete = c1.discrete, q.c1 = q.c1,
c0.mat = c0.mat, c0.discrete = c0.discrete, q.c0 = q.c0,
lambda.mat = lambda.mat,
lambda.discrete = lambda.discrete, q.lambda = q.lambda,
a = a, s = s, t = t, delta = delta,
nfolds = nfolds, type = c("int", "rct"))
res.hte
}
